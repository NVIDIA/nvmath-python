# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.

from datetime import datetime
from enum import Enum
import importlib
import inspect
import os
import re
import sys
sys.path.insert(0, os.path.abspath('.'))
import pkg_resources
import warnings

import numpy as np
import sphinx_rtd_theme

try:
    import nvmath
    from nvmath._internal.enum_utils import snake_to_camel
except ImportError:
    warnings.warn(
        "\n\n\n"
        "*************************************************************\n"
        "* Cannot import nvmath-python, some documentation might     *\n"
        "* not be rendered correctly.                                *\n"
        "*************************************************************\n\n"
    )
    nvmath = snake_to_camel = None


current_year = datetime.now().year

# -- Project information -----------------------------------------------------

project   = 'NVIDIA nvmath-python'
copyright = f"2024-{current_year}, NVIDIA Corporation & Affiliates"
author    = 'NVIDIA Corporation & Affiliates'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
with open("../../nvmath/_version.py") as f:
    exec(f.read())
    nvmath_py_ver = __version__
    del __version__

# The short X.Y version.
version = nvmath_py_ver

# The full version, including alpha/beta/rc tags.
release = nvmath_py_ver

# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    # 'sphinx.ext.imgmath',
    'sphinx.ext.ifconfig',
    #'breathe',
    'sphinx.ext.autodoc',
    'sphinx.ext.autosummary',
    'sphinx.ext.autosectionlabel',
    'sphinx.ext.doctest',      # test example codes in docs
    'sphinx.ext.extlinks',
    'sphinx.ext.intersphinx',
    #'sphinx.ext.mathjax',
    'sphinx.ext.napoleon',     # support google/numpy style docstrings
    'sphinx.ext.linkcode',
    'enum_tools.autoenum',     # for pretty-print Python enums
    'myst_parser',             # for including markdown files
    #'sphinxcontrib.autoprogram',
    'sphinxcontrib.programoutput',
    'sphinxcontrib.jquery',    # see https://github.com/readthedocs/sphinx_rtd_theme/issues/1452
]

imgmath_latex_preamble = r'\usepackage{braket}'

imgmath_image_format = 'svg'
imgmath_font_size    = 14
#imgmath_dvipng_args = ['-gamma', '1.5', '-D', '110', '-bg', 'Transparent']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = "en"

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']

# The reST default role (used for this markup: `text`) to use for all documents.
default_role = 'cpp:any' #cpp:any

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

highlight_language = 'python3'

# autosummary is buggy: this must be py instead of cpp so that the domain setting
# can be propagated to the autogen'd rst files.
primary_domain = 'py'

# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = 'sphinx_rtd_theme'
html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    "collapse_navigation" : False,
    "sticky_navigation" : False,
}

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Output file base name for HTML help builder.
htmlhelp_basename = 'nvmath-python-doc'


def autodoc_process_docstring(app, what, name, obj, options, lines):
    if snake_to_camel is None:
        return

    # there's no way we can touch the docstrings of np.dtype objects, so we
    # need to do post-processing here
    if isinstance(obj, np.dtype):
        _, *mod, struct = name.split(".")
        mod = '.'.join(mod)
        if mod == 'bindings': 
            # handle bindings
            struct = snake_to_camel([mod]+struct.split("_")[:-1])
            line = f"NumPy dtype object that represents the `{struct}` struct.\n"
        else:
            # handle dtype in high-level pythonic APIs
            struct = ' '.join(struct.split('_')[:-1])
            line = f"NumPy dtype object that encapsulates the {struct} in {mod}.\n"
        lines.clear()
        lines.append(line)
        lines.append("\n")
        for k in obj.fields.keys():
            lines.append(f":param {k}:\n")
    else:
        match_numba_dtype = re.search(r"nvmath.device.float(\d+)x(\d+)_type", name)
        if match_numba_dtype:
            lines.append(f"A Numba compliant vector type object for float{match_numba_dtype.group(1)} with vector length {match_numba_dtype.group(2)} \n")

    # Fix "Member Types" annotations
    lines = [l.replace(":Member Types:", "   :Member Types:") for l in lines]


def setup(app):
    app.add_css_file('nvmath_override.css')
    app.connect('autodoc-process-docstring', autodoc_process_docstring)


# -- Other options -------------------------------------------------

autosummary_generate = True

autosummary_filename_map = {
    # avoid name clash with the fft func
    "nvmath.fft.FFT": "nvmath.fft.FFT-class",
    "nvmath.linalg.advanced.Matmul": "nvmath.linalg.advanced.Matmul-class",
}

intersphinx_mapping = {
    'python': ('https://docs.python.org/3/', None),
    'numpy': ('https://numpy.org/doc/stable/', None),
    'cupy': ('https://docs.cupy.dev/en/stable/', None),
    'torch': ('https://pytorch.org/docs/stable/', None),
    'numba': ('https://numba.readthedocs.io/en/stable/', None),
    'cufft': ('https://docs.nvidia.com/cuda/cufft/', None),
}

napoleon_google_docstring = True
napoleon_numpy_docstring = False
autosectionlabel_prefix_document = True
# sweetspot value determined by trial & error to suppress all warnings
autosectionlabel_maxdepth = 2


doctest_global_setup = '''
import numpy as np
import cupy as cp
try:
    import torch
except ImportError:
    torch = None
np.random.seed(0)
cp.random.seed(100)
'''


# ======== Below are code added to enable sphinx.ext.linkcode ========

def _import_object_from_name(module_name, fullname):
    obj = sys.modules.get(module_name)
    if obj is None:
        return None
    for comp in fullname.split('.'):
        try:
            obj = getattr(obj, comp)
        except:
            return None
    return obj


_top_modules = ['nvmath']
_source_root = None


def _find_source_root(source_abs_path):
    global _source_root
    if _source_root is not None and source_abs_path.startswith(_source_root):
        return _source_root

    dirname = os.path.dirname(source_abs_path)
    while True:
        parent = os.path.dirname(dirname)
        if os.path.basename(dirname) in _top_modules:
            _source_root = parent
            return _source_root
        if len(parent) == len(dirname):
            raise RuntimeError(
                'Couldn\'t parse root directory from '
                'source file: {}'.format(source_abs_path))
        dirname = parent


def _get_source_relative_path(source_abs_path):
    return os.path.relpath(source_abs_path, _find_source_root(source_abs_path))


def _get_pyx_file(obj):
    try:
        filename = inspect.getfile(obj)
    except:
        # enum types (ex: Pauli) would not reach here, but enum values (ex:
        # Pauli.I) would, and it's a problem. Since the enum types would have
        # a url, let's avoid duplications here.
        if issubclass(type(obj), Enum):
            return None

        # inspect also fails with cpdef functions
        if hasattr(obj, '__module__') and "bindings" in obj.__module__:
            filename = obj.__module__.replace('.', '/') + '.pyx'
        else:
            raise
        assert filename.endswith('pyx')
        return filename
    else:
        # inspect succeeds with Python Enums
        for ext in importlib.machinery.EXTENSION_SUFFIXES:
            if filename.endswith(ext):
                filename = filename[:-len(ext)] + '.pyx'
                return filename
    return None


# Hook required by sphinx.ext.linkcode. Heavily influenced by
#   - CuPy:  https://github.com/cupy/cupy/blob/main/docs/source/conf.py
#   - NumPy: https://github.com/numpy/numpy/blob/main/doc/source/conf.py
#   - SciPy: https://github.com/scipy/scipy/blob/main/doc/source/conf.py
# For pure Python files, this should work just fine.
# For Cython files, the line number currently cannot be inferred due to Cython
# limitation (no information available for inspect to parse).
#
# Note for team: This function is designed to work for the public release.
# If you generate the docs with an internal build, the rendered docs likely
# will link to an unexpected place. In this case you should not inspect the docs,
# but simply check if the generated url points to the correct internal file
# (for both Python/Cython) and if the line number (for pure Python) is correct.

def linkcode_resolve(domain, info):
    if nvmath is None:
        return None

    if domain != 'py' or not info['module']:
        return None

    # Import the object from module path
    obj = _import_object_from_name(info['module'], info['fullname'])

    # If it's not defined in the internal module, return None.
    mod = inspect.getmodule(obj)
    if mod is None:
        return None
    if not mod.__name__.split('.')[0] in _top_modules:
        return None

    # If it's wrapped (e.g., by `contextlib.contextmanager`), unwrap it
    obj = inspect.unwrap(obj)

    # Get the source file name and line number at which obj is defined.
    try:
        filename = inspect.getsourcefile(obj)
    except TypeError:
        # obj is not a module, class, function, ..etc.
        filename = None

    # `inspect.getsourcefile` returns None for C-extension objects
    if filename is None:
        try:
            filename = _get_pyx_file(obj)
        except TypeError:
            return None
        else:
            if filename is None:
                return None
        linenum = None
    else:
        # Get the source line number
        _, linenum = inspect.getsourcelines(obj)
        assert isinstance(linenum, int)
    assert filename is not None

    filename = os.path.realpath(filename)
    relpath = _get_source_relative_path(filename)

    fragment = '' if linenum is None else f'#L{linenum}'
    branch = "main"  # always use the main branch for now

    return f"https://github.com/NVIDIA/nvmath-python/tree/{branch}/{relpath}{fragment}"
