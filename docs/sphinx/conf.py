# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.

from datetime import datetime
from enum import Enum
import importlib
import inspect
import os
import re
import sys
import tomllib
import tempfile
import json

sys.path.insert(0, os.path.abspath("."))
import warnings

from sphinx.writers.html import HTMLTranslator
from docutils.transforms import Transform
import docutils.nodes as nodes

import numpy as np

from enum_tools.autoenum import EnumDocumenter

try:
    import nvmath
    from nvmath.internal.enum_utils import snake_to_camel
except ImportError:
    warnings.warn(
        "\n\n\n"
        "*************************************************************\n"
        "* Cannot import nvmath-python, some documentation might     *\n"
        "* not be rendered correctly.                                *\n"
        "*************************************************************\n\n"
    )
    nvmath = snake_to_camel = None


current_year = datetime.now().year

# -- Project information -----------------------------------------------------

project = "NVIDIA nvmath-python"
copyright = f"2024-{current_year}, NVIDIA Corporation & Affiliates"
author = "NVIDIA Corporation & Affiliates"

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
with open("../../pyproject.toml", "rb") as f:
    nvmath_py_ver = tomllib.load(f)["project"]["version"]

# The short X.Y version.
version = nvmath_py_ver

# The full version, including alpha/beta/rc tags.
release = nvmath_py_ver

# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    # 'sphinx.ext.imgmath',
    "sphinx.ext.ifconfig",
    #'breathe',
    "sphinx.ext.autodoc",
    "sphinx.ext.autosummary",
    "sphinx.ext.autosectionlabel",
    "sphinx.ext.doctest",  # test example codes in docs
    "sphinx.ext.extlinks",
    "sphinx.ext.intersphinx",
    #'sphinx.ext.mathjax',
    "sphinx.ext.napoleon",  # support google/numpy style docstrings
    "sphinx.ext.linkcode",
    "enum_tools.autoenum",  # for pretty-print Python enums
    "myst_parser",  # for including markdown files
    #'sphinxcontrib.autoprogram',
    "sphinxcontrib.programoutput",
    "sphinx_favicon",
    "nbsphinx",
    "nbsphinx_link",
]

extlinks = {
    "cufftmp_hw": (
        "https://docs.nvidia.com/cuda/cufftmp/usage/requirements.html#hardware-%s",
        "p2p or GPUDirect RDMA over IB %s",
    )
}

imgmath_latex_preamble = r"\usepackage{braket}"

imgmath_image_format = "svg"
imgmath_font_size = 14
# imgmath_dvipng_args = ['-gamma', '1.5', '-D', '110', '-bg', 'Transparent']

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# Silence a warning about unpicklable value
nbsphinx_custom_formats = {}

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
source_suffix = ".rst"

# The master toctree document.
master_doc = "index"

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = "en"

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]

if tags.has("exclude-nvmath-distributed"):  # noqa: F821
    exclude_patterns += ["distributed-apis"]

# The reST default role (used for this markup: `text`) to use for all documents.
default_role = "cpp:any"  # cpp:any

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = "sphinx"

highlight_language = "python3"

# autosummary is buggy: this must be py instead of cpp so that the domain setting
# can be propagated to the autogen'd rst files.
primary_domain = "py"

# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = "nvidia_sphinx_theme"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    "switcher": {
        # This path should work for both for docs.nvidia.com and local `inv docs-view`
        "json_url": "/cuda/nvmath-python/latest/_static/switcher.json",
        "version_match": version,
    },
    "navbar_start": ["navbar-logo", "version-switcher"],
}
html_show_sphinx = False

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]

favicons = [
    {"rel": "apple-touch-icon", "href": "nvmath-python-apple-touch-icon.png"},
    "nvmath-python-favicon-32x32.png",
]

# Output file base name for HTML help builder.
htmlhelp_basename = "nvmath-python-doc"

# TODO: remove this once examples are published.
linkcheck_ignore = [
    "https://github.com/NVIDIA/nvmath-python/tree/main/examples/distributed/.*",
]


def autodoc_process_docstring(app, what, name, obj, options, lines):
    if snake_to_camel is None:
        return

    # there's no way we can touch the docstrings of np.dtype objects, so we
    # need to do post-processing here
    if isinstance(obj, np.dtype):
        _, *mod, struct = name.split(".")
        mod = ".".join(mod)
        if mod == "bindings":
            # handle bindings
            struct = snake_to_camel([mod] + struct.split("_")[:-1])
            line = f"NumPy dtype object that represents the `{struct}` struct.\n"
        else:
            # handle dtype in high-level Pythonic APIs
            struct = " ".join(struct.split("_")[:-1])
            line = f"NumPy dtype object that encapsulates the {struct} in {mod}.\n"
        lines.clear()
        lines.append(line)
        lines.append("\n")
        for k in obj.fields:
            lines.append(f":param {k}:\n")
    else:
        match_numba_dtype = re.search(r"nvmath.device.float(\d+)x(\d+)_type", name)
        if match_numba_dtype:
            lines.append(
                f"A Numba compliant vector type object for float{match_numba_dtype.group(1)} "
                f"with vector length {match_numba_dtype.group(2)} \n"
            )


class PatchedEnumDocumenter(EnumDocumenter):
    """
    Add missing newline to fix "Member Type" rendering for autoenum.
    """

    def generate(self, *args, **kwargs):
        super().generate(*args, **kwargs)
        for i in range(1, len(self.directive.result)):
            if self.directive.result[i - 1].startswith("   alias of"):  # noqa: SIM102
                if self.directive.result[i].startswith("   :Member Type:"):
                    self.directive.result.insert(i, "", "")


class DotBreakHtmlTranslator(HTMLTranslator):
    """
    Allow breaking long.qualified.function.names at dots to avoid overflows and random wraps
    """

    def should_break_at_dots(self, text):
        return re.match(r"nvmath\.[A-Za-z0-9._]+", text) is not None

    def visit_Text(self, node: nodes.Text) -> None:
        text = node.astext()
        if self.should_break_at_dots(text):
            self.body.append(text.replace(".", ".<wbr/>"))
        else:
            super().visit_Text(nodes.Text(text))


class UnqualifiedTitlesTransform(Transform):
    """
    Make nvmath.* titles unqualified to make them fit the line length
    """

    def apply(self):
        class Visitor(nodes.GenericNodeVisitor):
            def visit_title(self, node: nodes.Node):
                t = node.children[0].astext()
                if t.startswith("nvmath.") and " " not in t:
                    node.children[0] = nodes.Text(t.split(".")[-1])

            def default_visit(self, node):
                pass

            def default_departure(self, node):
                pass

        self.document.walk(Visitor(self.document))

    default_priority = 800


class NotebookHandler:
    def __init__(self):
        self.tmpdir = tempfile.mkdtemp()

    def __del__(self):
        os.unlink(self.tmpdir)

    def remove_notebook_copyright(self, app, docname, content):
        if os.path.exists(os.path.join("sphinx", docname + ".nblink")):
            link = json.loads(content[0])
            notebook_path = os.path.join("sphinx", os.path.dirname(docname), link["path"])

            with open(notebook_path) as original_notebook_file:
                notebook_content = json.load(original_notebook_file)
                copyright_regex = (
                    r"\s*Copyright \(c\) [0-9-]+, NVIDIA CORPORATION & AFFILIATES\s*SPDX-License-Identifier: BSD-3-Clause\s*"
                )
                if re.match(copyright_regex, "".join(notebook_content["cells"][0]["source"])):
                    # Remove first cell if it's a copyright notice
                    notebook_content["cells"] = notebook_content["cells"][1:]

            new_notebook_path = os.path.join(self.tmpdir, docname.replace(".nblink", ".ipynb").replace("/", "__"))
            with open(new_notebook_path, "w") as new_notebook_file:
                json.dump(notebook_content, new_notebook_file)

            link["path"] = os.path.relpath(new_notebook_path, os.path.join("sphinx", os.path.dirname(docname)))
            content[0] = json.dumps(link)


notebook_handler = NotebookHandler()


def setup(app):
    app.add_css_file("nvmath_override.css")
    app.connect("autodoc-process-docstring", autodoc_process_docstring)
    app.connect("source-read", lambda *args, **kwargs: notebook_handler.remove_notebook_copyright(*args, **kwargs))
    app.set_translator("html", DotBreakHtmlTranslator)
    app.add_autodocumenter(PatchedEnumDocumenter, override=True)
    app.add_post_transform(UnqualifiedTitlesTransform)


# -- Other options -------------------------------------------------

autosummary_generate = True

autosummary_filename_map = {
    # avoid name clash with the fft func
    "nvmath.fft.FFT": "nvmath.fft.FFT-class",
    "nvmath.linalg.advanced.Matmul": "nvmath.linalg.advanced.Matmul-class",
    "nvmath.distributed.fft.FFT": "nvmath.distributed.fft.FFT-class",
    "nvmath.distributed.reshape.Reshape": "nvmath.distributed.reshape.Reshape-class",
}

intersphinx_mapping = {
    "python": ("https://docs.python.org/3/", None),
    "numpy": ("https://numpy.org/doc/stable/", None),
    "cupy": ("https://docs.cupy.dev/en/stable/", None),
    "torch": ("https://pytorch.org/docs/stable/", None),
    "numba": ("https://numba.readthedocs.io/en/stable/", None),
    "cufft": ("https://docs.nvidia.com/cuda/cufft/", None),
}

napoleon_google_docstring = True
napoleon_numpy_docstring = False
autosectionlabel_prefix_document = True
# sweetspot value determined by trial & error to suppress all warnings
autosectionlabel_maxdepth = 2

show_warning_types = True
suppress_warnings = [
    "config.cache",  # nbsphinx_link makes nbsphinx_custom_formats unpicklable
]

doctest_global_setup = """
import numpy as np
import cupy as cp
try:
    import torch
except ImportError:
    torch = None
np.random.seed(0)
cp.random.seed(100)
"""


# ======== Below are code added to enable sphinx.ext.linkcode ========


def _import_object_from_name(module_name, fullname):
    obj = sys.modules.get(module_name)
    if obj is None:
        return None
    for comp in fullname.split("."):
        try:
            obj = getattr(obj, comp)
        except:
            return None
    return obj


_top_modules = ["nvmath"]
_source_root = None


def _find_source_root(source_abs_path):
    global _source_root
    if _source_root is not None and source_abs_path.startswith(_source_root):
        return _source_root

    dirname = os.path.dirname(source_abs_path)
    while True:
        parent = os.path.dirname(dirname)
        if os.path.basename(dirname) in _top_modules:
            _source_root = parent
            return _source_root
        if len(parent) == len(dirname):
            raise RuntimeError(f"Couldn't parse root directory from source file: {source_abs_path}")
        dirname = parent


def _get_source_relative_path(source_abs_path):
    return os.path.relpath(source_abs_path, _find_source_root(source_abs_path))


def _get_pyx_file(obj):
    try:
        filename = inspect.getfile(obj)
    except:
        # enum types (ex: Pauli) would not reach here, but enum values (ex:
        # Pauli.I) would, and it's a problem. Since the enum types would have
        # a url, let's avoid duplications here.
        if issubclass(type(obj), Enum):
            return None

        # inspect also fails with cpdef functions
        if hasattr(obj, "__module__") and "bindings" in obj.__module__:
            filename = obj.__module__.replace(".", "/") + ".pyx"
        else:
            raise
        assert filename.endswith("pyx")
        return filename
    else:
        # inspect succeeds with Python Enums
        for ext in importlib.machinery.EXTENSION_SUFFIXES:
            if filename.endswith(ext):
                filename = filename[: -len(ext)] + ".pyx"
                return filename
    return None


# Hook required by sphinx.ext.linkcode. Heavily influenced by
#   - CuPy:  https://github.com/cupy/cupy/blob/main/docs/source/conf.py
#   - NumPy: https://github.com/numpy/numpy/blob/main/doc/source/conf.py
#   - SciPy: https://github.com/scipy/scipy/blob/main/doc/source/conf.py
# For pure Python files, this should work just fine.
# For Cython files, the line number currently cannot be inferred due to Cython
# limitation (no information available for inspect to parse).
#
# Note for team: This function is designed to work for the public release.
# If you generate the docs with an internal build, the rendered docs likely
# will link to an unexpected place. In this case you should not inspect the docs,
# but simply check if the generated url points to the correct internal file
# (for both Python/Cython) and if the line number (for pure Python) is correct.


def linkcode_resolve(domain, info):
    if nvmath is None:
        return None

    if domain != "py" or not info["module"]:
        return None

    # Import the object from module path
    obj = _import_object_from_name(info["module"], info["fullname"])

    # If it's not defined in the internal module, return None.
    mod = inspect.getmodule(obj)
    if mod is None:
        return None
    if mod.__name__.split(".")[0] not in _top_modules:
        return None

    # If it's wrapped (by `contextlib.contextmanager` for example), unwrap it
    try:
        obj = inspect.unwrap(obj)
    except ValueError as e:
        # FIXME: This is a temporary fix for curand functions which have f.__wrapped__ == f.
        if "wrapper loop when unwrapping" in str(e):
            return None
        raise e

    # Get the source file name and line number at which obj is defined.
    try:
        filename = inspect.getsourcefile(obj)
    except TypeError:
        # obj is not a module, class, function, ..etc.
        filename = None

    # `inspect.getsourcefile` returns None for C-extension objects
    if filename is None:
        try:
            filename = _get_pyx_file(obj)
        except TypeError:
            return None
        else:
            if filename is None:
                return None
        linenum = None
    else:
        # Get the source line number
        _, linenum = inspect.getsourcelines(obj)
        assert isinstance(linenum, int)
    assert filename is not None

    filename = os.path.realpath(filename)
    relpath = _get_source_relative_path(filename)

    fragment = "" if linenum is None else f"#L{linenum}"
    branch = "main"  # always use the main branch for now

    return f"https://github.com/NVIDIA/nvmath-python/tree/{branch}/{relpath}{fragment}"
